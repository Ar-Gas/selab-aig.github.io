# 竞赛算法

<img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/算法竞赛 (1).png" alt="算法竞赛 (目录1)" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/算法竞赛 (2).png" alt="算法竞赛 (目录2)" style="zoom:67%;" />

模型的学习是十分重要的。

## 单调队列/栈

### 单调队列

使用双端队列，维护一个滑动的定长窗口$[i-m, i]$内的单调序列，从队头取最值，进行计算或转移。

每个元素从队尾入队，淘汰的元素从队尾出队；

滑出窗口的元素都是从队头出队，队头是当前窗口的最值。

```c++
int head = 1, back = 0; // init
for (int i = 1; i <= n; i ++){
    while (head <= back && a[q[back]] <= a[i]) back --; // 队尾出队
    q[++t] = i; //队尾入队
    if (q[head] < i - m + 1) head ++; // 队头入队
    cout << a[q[head]] << endl; //取队头值
}
```

### 单调栈

使用栈，维护一个固定的变长窗口$[1, i]$内的单调序列，从栈顶取最值，进行计算或转移。

每个元素从栈顶入栈，淘汰的元素从栈顶出栈，栈顶是当前窗口的最值

```c++
int top = 0; // 栈顶初值
for (int i = 1; i <= n ;i ++){
     while (top > 0 && a[q[top]] < a[i]){
         cout << a[q[top]] << endl; // 取栈顶值
         top --; // 栈顶出栈
     }
    q[++ top] = i; // 栈顶出栈
}
```

## 线段树

线段树用于维护区间信息（区间和、区间最值、区间GCD等），可以在logn的时间内执行**区间修改**和**区间查询**。

线段树中每个叶子节点储存元素本身，非子叶节点存储区间内元素的统计值。

- 优点：较快完成区间更新和查询
- 缺点：空间大(2n - 4n)

### 构造

结构体包含三个变量：l,r,sum：左节点、右节点和区间和。

```c++
#define left idx<< 1
#define right idx<< 1|1
struct node{
    int l, r, value, add; // 叶节点value为值，非叶节点value为区间和
}tree[N * 4];
```

父节点编号为p，左孩子为2p，右孩子为2p+1；

```c++
// [l, r]
void build(int l, int r, int idx)
{
	tree[idx].l = l;
	tree[idx].r = r;
	if (l == r) // 叶子节点
	{
		scanf("%d", &tree[idx].value);
		return;
	}
	int mid = (l + r) / 2;
	build(l, mid, left);									// 左孩子
	build(mid + 1, r, right);								// 右孩子
	tree[idx].value = tree[left].value + tree[right].value; // 状态合并，此结点的w=两个孩子的w之和
}
```

### 单点查询

```c++
void ask(int idx)
{
	if (tree[idx].l == tree[idx].r) // 当前结点的左右端点相等，是叶子节点，是最终答案
	{
		ans = tree[idx].value;
		return;
	}
	int mid = (tree[idx].l + tree[idx].r) / 2;
	if (x <= mid)
		ask(left); // 目标位置比中点靠左，就递归左孩子
	else
		ask(right); // 反之，递归右孩子
}
```

### 单点修改

```c++
void update(int idx)
{
	if (tree[idx].l == tree[idx].r) // 找到目标位置
	{
		tree[idx].value += y;
		return;
	}
	int mid = (tree[idx].l + tree[idx].r) / 2;
	if (x <= mid)
		update(left);
	else
		update(right);
	tree[idx].w = tree[left].w + tree[right].w; // 所有包含结点idx的结点状态更新
}
```

### 区间查询

1. 区间完全覆盖，回溯，返回sum；
2. 左节点与 $[x,y]$ 有重叠，递归返回左子树；
3. 右节点与 $[x,y]$ 有重叠，递归返回右子树；

```c++
void sum(int idx)
{
	if (tree[idx].l >= x && tree[idx].r <= y)
	{
		ans += tree[idx].value;
		return;
	}
	int mid = (tree[idx].l + tree[idx].r) / 2;
	if (x <= mid)
		sum(left);
	if (y > mid)
		sum(right);
}
```

### 区间修改

当 $[x,y]$ **完全覆盖**区间 $[a,b]$ 时，先修改该区间的 $sum$ 值，再打上一个**懒标记**，然后立刻返回，下次再查询时，再下传懒标记，这样修改和查询的时间复杂度：$O(logn)$。

### 懒标记

```c++
void pushup(int idx) // 向上更新
{
	tree[idx].sum = tree[left]
}
```



```c++
void pushdown(int idx) // 向下更新
{
	tree[left].add += tree[idx].add;
	tree[right].add += tree[idx].add;
	tree[left].value += tree[idx].add * (tree[left].r - tree[left].l + 1);
	tree[right].value += tree[idx].add * (tree[right].r - tree[right].l + 1);
	tree[idx].add = 0;
}
```

### 懒标记的区间修改

```c++
void update(int idx, int x, int y, int k) // k 为[x,y]上值的变化
{
	if (x <= tree[idx].l && tree[idx].r <= y) // 覆盖则修改
	{
		tree[idx].value += (tree[idx].r - tree[idx].l + 1) * k; // [x,y]区间点的总数
		tree[idx].add += k;
		return;
	}
	if (tree[idx].add)
		pushdown(idx); // 懒标记下传。只有不满足上面的if条件才执行
	int mid = (tree[idx].l + tree[idx].r) / 2; // 不覆盖则裂开
	if (x <= mid)
		add(left);
	if (y > mid)
		add(right);
	tree[idx].value = tree[left].value + tree[right].value; // 更改区间状态
}
```

### 懒标记的单点查询

```c++
void ask(int idx) // 单点查询
{
	if (tree[idx].l == tree[idx].r) // 找到
	{
		ans = tree[idx].value;
		return;
	}
	if (tree[idx].add)
		pushdown(idx); // 懒标记下传，唯一更改的地方
	int m = (tree[idx].l + tree[idx].r) / 2;
	if (x <= m)
		ask(left);
	else
		ask(right);
}
```

### 懒标记的区间查询

```c++
void sum(int idx) // 懒标记区间查询
{
	if (x <= tree[idx].l && tree[idx].r <= y)
	{
		ans += tree[idx].value;
		return;
	}
	if (tree[idx].f)
		down(idx) // 懒标记下传，唯一需要更改的地方
			int mid = (tree[idx].l + tree[idx].r) / 2;
	if (x <= mid)
		sum(left);
	if (y > mid)
		sum(right);
}
```

## 并查集

### 合并



### 查找





### 路径压缩-合并





### 路径压缩-查找







## KMP算法

 P 串匹配 T 串

### Next数组

Next[] 数组表示 P[1...i] 中相等前后缀的最长长度.

```c++
next[1] = 0;
for (int i = 2, j = 0; i <= n; i++)
{
	while (j && P[i] != p[j + 1])
		j = next[j];
	if (P[i] == p[j + 1])
		j++;
	next[i] = j;
}
```

使用双指针构造：

- i 扫描 P 串， j 扫描P的前缀

- 初始化： $next[1] = 0, i = 2, j = 0$

- 每轮 for 循环， i 向右走一步

  1. 若$P[i] != P[j + 1]$，让 j 跳到匹配的位置，如果不匹配，j 跳回 0
  2. 若$P[i]==P[ j + 1]$， j ++，指向匹配前缀的末尾。
  3. next[i] 等于 j 的值

  时间复杂度的计算：来自 [F03【模板】KMP 算法](https://www.bilibili.com/video/BV1Ag411o7US/?spm_id_from=333.999.0.0&vd_source=607514df4428a309d5130d87a0423d0c)

  

  <img src="https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20240317150842763.png" alt="image-20240317150842763" style="zoom:67%;" />

### KMP匹配

匹配失败时，P 串回退（已匹配的字符数 - Next[]中对应的值）位。

```c++
// KMP匹配
size_t p_szie = P.szie();
size_t t_szie = T.szie();
int idx_p = 0, idx_t = 0, n_match = 0, cnt = 0;
for (; idx_t <= t_size; idx_t++)
{
	while (P[idx_p] != T[idx_t] && n_match) // 回退
	{ 
		idx_p -= (n_match - next[idx_p]);
		n_match -= (n_match - next[idx_p]);
	}
	if (P[idx_p] == T[idx_t])  // 部分匹配成功
	{
		n_match++;
		idx_p++;
	}
	if (idx_p == p_size) // 匹配成功
	{ 
		cnt++;
		idx_p = 0;
	}
}
```



## 大数运算

一般C++需要，Java/Python忽略

### 大数存储

用数组/字符数组/字符串

![img](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/20200728155101804.png)

### 思路

模拟：加减乘类似小学运算，除法使用减法

### 加法

```c++
for (i = 0; i < max; i++)
{
	c[i] += a[i] + b[i];
	if (c[i] >= 10)
	{				   // 进位处理
		c[i + 1] += 1; // 进10位
		c[i] %= 10;	   // 留下个位
	}
}
```

### 减法





### 乘法







### 除法



### 模板

参考[【大数模板】C++大数类 大数模板 ](https://www.cnblogs.com/zhengbin/p/4368182.html)

```c++
#include<iostream> 
#include<cstring>  
#include<string>   
#include<iomanip>   
#include<algorithm>   
using namespace std;   
  
#define MAXN 9999  
#define MAXSIZE 10  
#define DLEN 4  
  
class BigNum  
{   
private:   
    int a[500];    //可以控制大数的位数   
    int len;       //大数长度  
public:   
    BigNum(){ len = 1;memset(a,0,sizeof(a)); }   //构造函数  
    BigNum(const int);       //将一个int类型的变量转化为大数  
    BigNum(const char*);     //将一个字符串类型的变量转化为大数  
    BigNum(const BigNum &);  //拷贝构造函数  
    BigNum &operator=(const BigNum &);   //重载赋值运算符，大数之间进行赋值运算  
  
    friend istream& operator>>(istream&,  BigNum&);   //重载输入运算符  
    friend ostream& operator<<(ostream&,  BigNum&);   //重载输出运算符  
  
    BigNum operator+(const BigNum &) const;   //重载加法运算符，两个大数之间的相加运算   
    BigNum operator-(const BigNum &) const;   //重载减法运算符，两个大数之间的相减运算   
    BigNum operator*(const BigNum &) const;   //重载乘法运算符，两个大数之间的相乘运算   
    BigNum operator/(const int   &) const;    //重载除法运算符，大数对一个整数进行相除运算  
  
    BigNum operator^(const int  &) const;    //大数的n次方运算  
    int    operator%(const int  &) const;    //大数对一个int类型的变量进行取模运算      
    bool   operator>(const BigNum & T)const;   //大数和另一个大数的大小比较  
    bool   operator>(const int & t)const;      //大数和一个int类型的变量的大小比较  
  
    void print();       //输出大数  
};   
BigNum::BigNum(const int b)     //将一个int类型的变量转化为大数  
{   
    int c,d = b;  
    len = 0;  
    memset(a,0,sizeof(a));  
    while(d > MAXN)  
    {  
        c = d - (d / (MAXN + 1)) * (MAXN + 1);   
        d = d / (MAXN + 1);  
        a[len++] = c;  
    }  
    a[len++] = d;  
}  
BigNum::BigNum(const char*s)     //将一个字符串类型的变量转化为大数  
{  
    int t,k,index,l,i;  
    memset(a,0,sizeof(a));  
    l=strlen(s);     
    len=l/DLEN;  
    if(l%DLEN)  
        len++;  
    index=0;  
    for(i=l-1;i>=0;i-=DLEN)  
    {  
        t=0;  
        k=i-DLEN+1;  
        if(k<0)  
            k=0;  
        for(int j=k;j<=i;j++)  
            t=t*10+s[j]-'0';  
        a[index++]=t;  
    }  
}  
BigNum::BigNum(const BigNum & T) : len(T.len)  //拷贝构造函数  
{   
    int i;   
    memset(a,0,sizeof(a));   
    for(i = 0 ; i < len ; i++)  
        a[i] = T.a[i];   
}   
BigNum & BigNum::operator=(const BigNum & n)   //重载赋值运算符，大数之间进行赋值运算  
{  
    int i;  
    len = n.len;  
    memset(a,0,sizeof(a));   
    for(i = 0 ; i < len ; i++)   
        a[i] = n.a[i];   
    return *this;   
}  
istream& operator>>(istream & in,  BigNum & b)   //重载输入运算符  
{  
    char ch[MAXSIZE*4];  
    int i = -1;  
    in>>ch;  
    int l=strlen(ch);  
    int count=0,sum=0;  
    for(i=l-1;i>=0;)  
    {  
        sum = 0;  
        int t=1;  
        for(int j=0;j<4&&i>=0;j++,i--,t*=10)  
        {  
            sum+=(ch[i]-'0')*t;  
        }  
        b.a[count]=sum;  
        count++;  
    }  
    b.len =count++;  
    return in;  
  
}  
ostream& operator<<(ostream& out,  BigNum& b)   //重载输出运算符  
{  
    int i;    
    cout << b.a[b.len - 1];   
    for(i = b.len - 2 ; i >= 0 ; i--)  
    {   
        cout.width(DLEN);   
        cout.fill('0');   
        cout << b.a[i];   
    }   
    return out;  
}  
  
BigNum BigNum::operator+(const BigNum & T) const   //两个大数之间的相加运算  
{  
    BigNum t(*this);  
    int i,big;      //位数     
    big = T.len > len ? T.len : len;   
    for(i = 0 ; i < big ; i++)   
    {   
        t.a[i] +=T.a[i];   
        if(t.a[i] > MAXN)   
        {   
            t.a[i + 1]++;   
            t.a[i] -=MAXN+1;   
        }   
    }   
    if(t.a[big] != 0)  
        t.len = big + 1;   
    else  
        t.len = big;     
    return t;  
}  
BigNum BigNum::operator-(const BigNum & T) const   //两个大数之间的相减运算   
{    
    int i,j,big;  
    bool flag;  
    BigNum t1,t2;  
    if(*this>T)  
    {  
        t1=*this;  
        t2=T;  
        flag=0;  
    }  
    else  
    {  
        t1=T;  
        t2=*this;  
        flag=1;  
    }  
    big=t1.len;  
    for(i = 0 ; i < big ; i++)  
    {  
        if(t1.a[i] < t2.a[i])  
        {   
            j = i + 1;   
            while(t1.a[j] == 0)  
                j++;   
            t1.a[j--]--;   
            while(j > i)  
                t1.a[j--] += MAXN;  
            t1.a[i] += MAXN + 1 - t2.a[i];   
        }   
        else  
            t1.a[i] -= t2.a[i];  
    }  
    t1.len = big;  
    while(t1.a[t1.len - 1] == 0 && t1.len > 1)  
    {  
        t1.len--;   
        big--;  
    }  
    if(flag)  
        t1.a[big-1]=0-t1.a[big-1];  
    return t1;   
}   
  
BigNum BigNum::operator*(const BigNum & T) const   //两个大数之间的相乘运算   
{   
    BigNum ret;   
    int i,j,up;   
    int temp,temp1;     
    for(i = 0 ; i < len ; i++)  
    {   
        up = 0;   
        for(j = 0 ; j < T.len ; j++)  
        {   
            temp = a[i] * T.a[j] + ret.a[i + j] + up;   
            if(temp > MAXN)  
            {   
                temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);   
                up = temp / (MAXN + 1);   
                ret.a[i + j] = temp1;   
            }   
            else  
            {   
                up = 0;   
                ret.a[i + j] = temp;   
            }   
        }   
        if(up != 0)   
            ret.a[i + j] = up;   
    }   
    ret.len = i + j;   
    while(ret.a[ret.len - 1] == 0 && ret.len > 1)  
        ret.len--;   
    return ret;   
}   
BigNum BigNum::operator/(const int & b) const   //大数对一个整数进行相除运算  
{   
    BigNum ret;   
    int i,down = 0;     
    for(i = len - 1 ; i >= 0 ; i--)  
    {   
        ret.a[i] = (a[i] + down * (MAXN + 1)) / b;   
        down = a[i] + down * (MAXN + 1) - ret.a[i] * b;   
    }   
    ret.len = len;   
    while(ret.a[ret.len - 1] == 0 && ret.len > 1)  
        ret.len--;   
    return ret;   
}  
int BigNum::operator %(const int & b) const    //大数对一个int类型的变量进行取模运算      
{  
    int i,d=0;  
    for (i = len-1; i>=0; i--)  
    {  
        d = ((d * (MAXN+1))% b + a[i])% b;    
    }  
    return d;  
}  
BigNum BigNum::operator^(const int & n) const    //大数的n次方运算  
{  
    BigNum t,ret(1);  
    int i;  
    if(n<0)  
        exit(-1);  
    if(n==0)  
        return 1;  
    if(n==1)  
        return *this;  
    int m=n;  
    while(m>1)  
    {  
        t=*this;  
        for( i=1;i<<1<=m;i<<=1)  
        {  
            t=t*t;  
        }  
        m-=i;  
        ret=ret*t;  
        if(m==1)  
            ret=ret*(*this);  
    }  
    return ret;  
}  
bool BigNum::operator>(const BigNum & T) const   //大数和另一个大数的大小比较  
{   
    int ln;   
    if(len > T.len)  
        return true;   
    else if(len == T.len)  
    {   
        ln = len - 1;   
        while(a[ln] == T.a[ln] && ln >= 0)  
            ln--;   
        if(ln >= 0 && a[ln] > T.a[ln])  
            return true;   
        else  
            return false;   
    }   
    else  
        return false;   
}  
bool BigNum::operator >(const int & t) const    //大数和一个int类型的变量的大小比较  
{  
    BigNum b(t);  
    return *this>b;  
}  
  
void BigNum::print()    //输出大数  
{   
    int i;     
    cout << a[len - 1];   
    for(i = len - 2 ; i >= 0 ; i--)  
    {   
        cout.width(DLEN);   
        cout.fill('0');   
        cout << a[i];   
    }   
    cout << endl;  
}  
int main(){  
    int i,n;  
    BigNum h[101];      //定义大数的对象数组  
    h[0]=1;  
    for(i=1;i<101;i++)  
        h[i]=h[i-1]*(4*i-2)/(i+1);  
    while(scanf("%d",&n)==1 && n!=-1){  
        h[n].print();  
    }  
} 
```



### 附：Python思路

![Python读入板子（部分）](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/Snipaste_2024-03-19_17-40-12.png)

其实把数字读进去就行

例：

```python
// https://codeforces.com/contest/1945/problem/B

II = lambda: int(input())
MII = lambda: map(int, input().split())
for _ in range (II()):
    a,b,c = MII()
    tt = 2
    tt += c//b
    tt += c//a
    print(tt)
```

## 动态规划（DP）

“优美”的优化，就是状态 + 状态转移方程。

### 背包PD

### 区间DP

题：

![image-20240321152658336](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20240321152658336.png)

解答：

![image-20240321152717361](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20240321152717361.png)

代码：

![image-20240321152632964](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/image-20240321152632964.png)

### 树上DP

### 树状DP

### 状压DP

### 状压DP

### 动态DP

## 树上问题

### 树基础

树基础是

#### 根

一个没有固定根结点的树称为 **无根树**，包括：

- 有 n 个结点，n - 1 条边的连通无向图

- 无向无环的连通图
- 任意两个结点之间有且仅有一条简单路径的无向图
- 任何边均为桥的连通图
- 没有圈，且在任意不同两点间添加一条边之后所得图含唯一的一个圈的图

无根树指定一个结点称为 **根**，则形成一棵 **有根树**。有根树在很多时候仍以无向图表示，只是规定了结点之间的上下级关系。

#### 有关树的定义

##### 适用于无根树和有根树

- **森林（forest）**：每个连通分量（连通块）都是树的图。按照定义，一棵树也是森林。
- **生成树（spanning tree）**：一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择 n - 1 条，将所有顶点连通。
- **无根树的叶结点（leaf node）**：度数不超过 1 的结点。

- **有根树的叶结点（leaf node）**：没有子结点的结点。

##### 只适用于有根树

- **父亲（parent node）**：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。
  根结点没有父结点。
- **祖先（ancestor）**：一个结点到根结点的路径上，除了它本身外的结点。
  根结点的祖先集合为空。
- **子结点（child node）**：如果 u 是 v 的父亲，那么 v 是 u 的子结点。
  子结点的顺序一般不加以区分，二叉树是一个例外。
- **结点的深度（depth）**：到根结点的路径上的边数。
- **树的高度（height）**：所有结点的深度的最大值。
- **兄弟（sibling）**：同一个父亲的多个子结点互为兄弟。
- **后代（descendant）**：子结点和子结点的后代。
  或者理解成：如果 u 是 v 的祖先，那么 v是 u 的后代。
- **子树（subtree）**：删掉与父亲相连的边后，该结点所在的子图。

![tree-definition.svg](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-definition.svg)

![tree-definition-subtree.svg](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-definition-subtree.svg)

##### 特殊的树

- **链**：满足与任一结点相连的边不超过 2 条的树称为链
- **菊花/星星**：满足存在 u 使得所有除 u 以外结点均与 u 相连的树称为菊花。
- **有根二叉树**：每个结点最多只有两个儿子（子结点）的有根树称为二叉树。常常对两个子结点的顺序加以区分，分别称之为左子结点和右子结点。大多数情况下，二叉树 一词均指有根二叉树。

- **完整二叉树**：每个结点的子结点数量**均为 0 或者 2** 的二叉树。换言之，每个结点或者是树叶，或者左右子树均非空。

![img](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-binary-proper.svg)

- **完全二叉树**：只有**最下面两层**结点的度数**可以小于 2**，且最下面一层的结点都集中在该层**最左边**的连续位置上。

![img](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-binary-complete.svg)

- **完美二叉树（perfect binary tree）**：**所有叶结点的深度均相同**，且所有非叶节点的子节点数量**均为 2** 的二叉树称为完美二叉树。

![img](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-binary-perfect.svg)

#### 存储

- 只记录父节点
- 邻接表
- 左孩子右兄弟表示法
- 二叉树

##### 只记录父结点

只记录`parent[N]`.

常用于自底向上的递推问题中.

##### 邻接表

- 无根树：为每个结点开辟一个线性列表，记录所有与之相连的结点。

    ```c++
    std::vector<int> adj[N]; // 也可以用链表等
    ```

- 有根树

    - 方法一：无向图同上

    - 方法二：若有上下级关系，就可以利用这个信息，为每个结点开辟一个线性列表，记录其所有子结点；若有需要，还可在另一个数组中记录其父结点。

      ```c++
      std::vector<int> children[N];
      int parent[N];
      ```

##### 左孩子右兄弟表示法

有根树的另一种表示：

- 首先，给每个结点的所有子结点任意确定一个顺序;

- 记录**第一个子结点** `child[u]` 和其 **下一个兄弟结点** `sib[0u]`，若没有节点则为空。

    ```c++
    int v = child[u];  // 从第一个子结点开始
    while (v != EMPTY_NODE) {
      // ...
      // 处理子结点 v
      // ...
      v = sib[v];  // 转至下一个子结点，即 v 的一个兄弟
    }
    ```

或者简写成以下形式：

```c++
for (int v = child[u]; v != EMPTY_NODE; v = sib[v]) {
  // ...
  // 处理子结点 v
  // ...
}
```

##### 二叉树

记录每个结点的左右子结点和父节点。

```c++
int parent[N];
int lch[N], rch[N];
// -- or --
int child[N][2];
```

#### 树的遍历

##### 二叉树 DFS 遍历

先访问根节点，然后分别访问根节点每个儿子的子树.

可以求出每个节点的深度、父亲等信息.

1. 先序遍历

按照 **根，左，右** 的顺序遍历二叉树。

```c++
void preorder(BiTree* root) 
{
  if (root) 
  {
    cout << root->key << " ";
    preorder(root->left);
    preorder(root->right);
  }
}
```

2. 中序遍历

按照 **左，根，右 **的顺序遍历二叉树。

```c++
void inorder(BiTree* root) 
{
  if (root) 
  {
    inorder(root->left);
    cout << root->key << " ";
    inorder(root->right);
  }
}
```

3. 后序遍历

按照 **左，右，根** 的顺序遍历二叉树。

```c++
void postorder(BiTree * root)
{
    if (root)
    {
        postorder(root->left);
        postorder(root->right);
        cout << root->key << " ";
    }
}
```

##### 二叉树 BFS 遍历

从树根开始，严格按照层次来访问节点；

遍历过程也可以求出各个节点的深度和父亲节点。

层序遍历要求将不同的层次区分开来，所以其结果通常以二维数组的形式表示

```c++
vector<vector<int>> levelOrder(Node *root)
{
	if (!root)
	{
		return {};
	}
	vector<vector<int>> res;
	queue<Node *> q;
	q.push(root);
	while (!q.empty())
	{
		int currentLevelSize = q.size(); // 当前层的节点个数
		res.push_back(vector<int>());
		for (int i = 0; i < currentLevelSize; ++i)
		{
			Node *cur = q.front();
			q.pop();
			res.back().push_back(cur->val);
			for (Node *child : cur->children)
			{ // 把子节点都加入
				q.push(child);
			}
		}
	}
	return res;
}
```

##### 反推

已知中序遍历序列和另外一个序列可以求第三个序列：

![reverse](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-basic-reverse.svg)

1. 前序的第一个是 `root`，后序的最后一个是 `root`。
2. 先确定根节点，然后根据中序遍历，在根左边的为左子树，根右边的为右子树。
3. 对于每一个子树可以看成一个全新的树，仍然遵循上面的规律。

##### 二叉树 Morris 遍历

Morris 遍历的实质是避免使用栈，利用底层节点空闲的 `right` 指针指回上层的某个节点，从而完成下层到上层的移动。

假设来到当前节点 `cur`，开始时来到根节点位置。

1. 如果 `cur` 为空时遍历停止，否则进行以下过程。

2. 如果 `cur` 没有左子树，`cur` 向右移动（`cur = cur->right`）。

3. 如果`cur`有左子树，找到左子树上最右的节点，记为`mostRight`.

   - 如果 `mostRight` 的 `right` 指针指向空，让其指向 `cur`，然后 `cur` 向左移动（`cur = cur->left`）。

   - 如果 `mostRight` 的 `right` 指针指向 `cur`，将其修改为 `null`，然后 `cur` 向右移动（`cur = cur->right`）。

可以发现有左子树的节点访问两次，没有左子树的节点只访问一次。

![tree-basic-morris-2](https://raw.githubusercontent.com/Ar-Gas/Ar-Gas.github.io/main/photo/tree-basic-morris-2.svg)

```c++
void morris(TreeNode* root) {
  TreeNode* cur = root;
  while (cur) {
    if (!cur->left) {
      // 如果当前节点没有左子节点，则输出当前节点的值并进入右子树
      std::cout << cur->val << " ";
      cur = cur->right;
      continue;
    }
    // 找到当前节点的左子树的最右节点
    TreeNode* mostRight = cur->left;
    while (mostRight->right && mostRight->right != cur) {
      mostRight = mostRight->right;
    }
    if (!mostRight->right) {
      // 如果最右节点的right指针为空，将其指向当前节点，并进入左子树
      mostRight->right = cur;
      cur = cur->left;
    } else {
      // 如果最右节点的right指针指向当前节点，说明左子树已经遍历完毕，输出当前节点的值并进入右子树
      mostRight->right = nullptr;
      std::cout << cur->val << " ";
      cur = cur->right;
    }
  }
}
```

#### 无根树

树的遍历一般为深度优先遍历，这个过程中最需要注意的是避免重复访问结点。

由于树是无环图，因此只需记录当前结点是由哪个结点访问而来，此后进入除该结点外的所有相邻结点，即可避免重复访问。

```c++
void dfs(int u, int from) {
  // 递归进入除了 from 之外的所有子结点
  // 对于出发结点，from 为空，故会访问所有相邻结点，这与期望一致
  for (int v : adj[u])
    if (v != from) {
      dfs(v, u);
    }
}

// 开始遍历时
int EMPTY_NODE = -1;  // 一个不存在的编号
int root = 0;         // 任取一个结点作为出发点
dfs(root, EMPTY_NODE);
```

#### 有根树

对于有根树，需要区分结点的上下关系。

参无根图，若从根开始遍历，则访问到一个结点时 `from` 的值，就是其父结点的编号。

可以对于无向的输入求出所有结点的父结点，以及子结点列表。

### 树的直径

**树上任意两节点之间最长的简单路径即为树的「直径」**

显然，一棵树可以有多条直径，他们的长度相等。

可以用两次 DFS 或者树形 DP 的方法在 $O(n)$ 时间求出树的直径。

#### 



























# 参考资料

[1]. [oi.wiki](oi.wiki)

[2].[董晓算法](https://space.bilibili.com/517494241)
